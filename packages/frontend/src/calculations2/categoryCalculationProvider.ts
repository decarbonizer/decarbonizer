import { DataFrame, IDataFrame } from 'data-forge';
import { ActionAnswerBase } from '../api/actionAnswer';
import { isSurveyAnswerType, SurveyAnswer } from '../api/surveyAnswer';
import { ExternalCalculationData } from '../calculations/externalData';
import { KnownSurveyId, SurveyToSurveyAnswerMap } from '../data/surveys/survey';
import { DeltaResult, getDeltaType } from '../utils/deltaType';

const emptyDataFrame = new DataFrame();

export interface CostDescriptor {
  displayName: string;
  cost: number;
}

export abstract class CategoryCalculationProvider<
  TSurveyId extends KnownSurveyId = KnownSurveyId,
  TSurveyAnswerValue extends SurveyToSurveyAnswerMap[TSurveyId] = SurveyToSurveyAnswerMap[TSurveyId],
> {
  protected constructor(protected surveyId: TSurveyId, protected externalCalculationData: ExternalCalculationData) {}

  //
  // Investment Costs.
  //

  public getTotalSummedInvestmentCosts(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
    transformingActionAnswers: IDataFrame<number, ActionAnswerBase> = emptyDataFrame,
  ) {
    const surveyAnswersToUse = this.transformSurveyAnswers(surveyAnswers, transformingActionAnswers);

    if (!surveyAnswersToUse.any()) {
      return 0;
    }

    return surveyAnswers
      .flatMap((surveyAnswer) => this.getInvestmentCostsForSingleSurveyAnswer(surveyAnswer))
      .reduce((result, cost) => result + cost.cost, 0);
  }

  /**
   * Gets the initial investment cost required by the given survey answer.
   * Investment costs only occur once when the given installation/data is implemented.
   * An example is the purchase of new hardware.
   */
  public abstract getInvestmentCostsForSingleSurveyAnswer(
    surveyAnswer: SurveyAnswer<TSurveyAnswerValue>,
  ): IDataFrame<number, CostDescriptor>;

  //
  // Yearly Changing Costs.
  //

  public getTotalSummedYearlyChangingCosts(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
    transformingActionAnswers: IDataFrame<number, ActionAnswerBase> = emptyDataFrame,
    year: number,
  ) {
    const surveyAnswersToUse = this.transformSurveyAnswers(surveyAnswers, transformingActionAnswers);

    if (!surveyAnswersToUse.any()) {
      return 0;
    }

    return surveyAnswersToUse
      .flatMap((surveyAnswer) => this.getYearlyChangingCostsForSingleSurveyAnswer(surveyAnswer, year))
      .reduce((result, cost) => result + cost.cost, 0);
  }

  /**
   * Gets yearly changing costs created by the given survey answer.
   * Changing costs are *not* constant and change every year. An example is the maintenance
   * of bulbs which is only required every n years depending on the bulb's usage.
   */
  public abstract getYearlyChangingCostsForSingleSurveyAnswer(
    surveyAnswer: SurveyAnswer<TSurveyAnswerValue>,
    year: number,
  ): IDataFrame<number, CostDescriptor>;

  //
  // Yearly Constant Costs.
  //

  /**
   * Returns the delta between all total constant costs occuring in a single year before and after
   * applying the transforming action answers.
   */
  public getTotalYearlyConstantCostsDelta(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
    transformingActionAnswers: IDataFrame<number, ActionAnswerBase>,
  ) {
    return this.getDeltaResult(
      this.getTotalSummedYearlyConstantCosts(surveyAnswers),
      this.getTotalSummedYearlyConstantCosts(surveyAnswers, transformingActionAnswers),
    );
  }

  /**
   * Returns the sum of all total constant costs occuring in a single year.
   */
  public getTotalSummedYearlyConstantCosts(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
    transformingActionAnswers: IDataFrame<number, ActionAnswerBase> = emptyDataFrame,
  ) {
    const surveyAnswersToUse = this.transformSurveyAnswers(surveyAnswers, transformingActionAnswers);

    if (!surveyAnswersToUse.any()) {
      return 0;
    }

    return surveyAnswersToUse
      .flatMap((surveyAnswer) => this.getYearlyConstantCostsForSingleSurveyAnswer(surveyAnswer))
      .reduce((result, cost) => result + cost.cost, 0);
  }

  /**
   * Gets the constant costs created by the given survey answer.
   * Constant costs are constant and occur every year. An example is the average electricity cost
   * generated by the same room every year.
   */
  public abstract getYearlyConstantCostsForSingleSurveyAnswer(
    surveyAnswer: SurveyAnswer<TSurveyAnswerValue>,
  ): IDataFrame<number, CostDescriptor>;

  //
  // Footprint Calculation.
  //

  public getSummedYearlyFootprintDelta(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
    transformingActionAnswers: IDataFrame<number, ActionAnswerBase>,
  ): DeltaResult {
    return this.getDeltaResult(
      this.getSummedYearlyFootprint(surveyAnswers),
      this.getSummedYearlyFootprint(surveyAnswers, transformingActionAnswers),
    );
  }

  public getSummedYearlyFootprint(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
    transformingActionAnswers: IDataFrame<number, ActionAnswerBase> = emptyDataFrame,
  ) {
    const surveyAnswersToUse = this.transformSurveyAnswers(surveyAnswers, transformingActionAnswers);

    if (!surveyAnswersToUse.any()) {
      return 0;
    }

    return surveyAnswersToUse
      .map((surveyAnswer) => this.getYearlyFootprintForSingleSurveyAnswer(surveyAnswer))
      .reduce((result, footprint) => result + footprint, 0);
  }

  public abstract getYearlyFootprintForSingleSurveyAnswer(surveyAnswer: SurveyAnswer<TSurveyAnswerValue>): number;

  //
  // Survey Answer Transformation.
  //

  public transformSurveyAnswers(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
    actionAnswers: IDataFrame<number, ActionAnswerBase>,
  ): IDataFrame<number, SurveyAnswer<TSurveyAnswerValue>> {
    const matchingSurveyAnswers = this.filterThisCategorysSurveyAnswers(surveyAnswers);
    return matchingSurveyAnswers.map((surveyAnswer) => this.transformSurveyAnswer(surveyAnswer, actionAnswers));
  }

  public abstract transformSurveyAnswer(
    surveyAnswer: SurveyAnswer<TSurveyAnswerValue>,
    actionAnswers: IDataFrame<number, ActionAnswerBase>,
  ): SurveyAnswer<TSurveyAnswerValue>;

  //
  // Helpers.
  //

  protected filterThisCategorysSurveyAnswers(
    surveyAnswers: IDataFrame<number, SurveyAnswer>,
  ): IDataFrame<number, SurveyAnswer<TSurveyAnswerValue>> {
    return surveyAnswers.filter((surveyAnswer) => isSurveyAnswerType(this.surveyId, surveyAnswer)) as any;
  }

  protected getDeltaResult(before: number, after: number) {
    const delta = after - before;
    const deltaType = getDeltaType(delta);

    return {
      before,
      after,
      delta,
      deltaType,
    };
  }
}
